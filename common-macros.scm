(module common-macros (ds-set! ds-let ds-define)
  (import scheme chicken)

  (define-syntax ds-define-false
    (syntax-rules (o)
      ((_ ()) (void))
      ((_ ((o arg val) . rest))
       (begin
         (define arg #f)
         (ds-define-false rest)))
      ((_ (arg . rest))
       (begin
         (ds-define-false arg)
         (ds-define-false rest)))
      ((_ arg)
       (define arg #f))))

  (define-for-syntax (ds-let-helper vars rest body compare?)
     (if (null? vars) 
       `(begin ,@body)
       (if (atom? vars)
         `(let ((,vars ,rest)) ,@body)
         (let ((var (car vars)))
           (if (null? (cdr vars))
             (if (pair? var)
               (if (compare? (car var) 'o)
                 ;;(ds-let ((o x val)) lst body ...)
                 `(let ((,(cadr var) 
                          (if (null? ,rest) ,(caddr var) (car ,rest))))
                    ,@body)
                 ;;(ds-let ((x y ...)) lst body ...)
                 `(let ((,rest (car ,rest)))
                    ,(ds-let-helper var rest body compare?)))
               ;;(ds-let (x) lst body ...)
               `(let ((,var (car ,rest))) ,@body))
             (if (pair? var)
               (if (compare? (car var) 'o)
                 (if (atom? (cdr vars))
                   ;;(ds-let ((o x val) . rest) lst body ...)
                   `(let ((,(cadr var) 
                            (if (null? ,rest) ,(caddr var) (car ,rest))) 
                          (,(cdr vars) 
                            (if (null? ,rest) '() (cdr ,rest)))) ,@body)
                   ;;(ds-let ((o x val) y z ...) lst body ...)
                   `(let ((,(cadr var) 
                            (if (null? ,rest) ,(caddr var) (car ,rest))) 
                          (,rest (if (null? ,rest) '() (cdr ,rest))))
                      ,(ds-let-helper (cdr vars) rest body compare?)))
                 (let ((head (gensym)))
                   (if (atom? (cdr vars))
                     ;;(ds-let ((a b c ...) . rest) lst body ...)
                     `(let ((,head (car ,rest))) 
                        ,(ds-let-helper var head
                                        (list `(let ((,(cdr vars) (cdr ,rest))) ,@body))
                                        compare?))
                     ;;(ds-let ((a b c ...) x y ...) lst body ...)
                     `(let ((,head (car ,rest)) (,rest (cdr ,rest)))
                        ,(ds-let-helper var head 
                                        (list (ds-let-helper (cdr vars) rest body compare?))
                                        compare?)))))
               (if (atom? (cdr vars))
                 ;;(ds-let (x . y) lst body ...)
                 `(let ((,var (car ,rest)) (,(cdr vars) (cdr ,rest))) ,@body)
                 ;;(ds-let (x y z ...) lst body ...)  
                 `(let ((,var (car ,rest)) (,rest (cdr ,rest)))
                    ,(ds-let-helper (cdr vars) rest body compare?)))))))))
  
  (define-syntax ds-let
    (ir-macro-transformer
      (lambda (expr inject compare?)
        (let ((vars (cadr expr))
              (vals (caddr expr))
              (body (cdddr expr))
              (rest 'rest))
          `(let ((rest ,vals))
              ,(ds-let-helper vars rest body compare?))))))

  
  (define-for-syntax (ds-set!-helper vars rest compare?)
     (if (null? vars) 
       `(void)
       (if (atom? vars)
         `(set! ,vars ,rest)
         (let ((var (car vars)))
           (if (null? (cdr vars))
             (if (pair? var)
               (if (compare? (car var) 'o)
                 ;;(ds-set! ((o x val)) lst)
                 `(set! ,(cadr var) 
                    (if (null? ,rest) ,(caddr var) (car ,rest)))
                 ;;(ds-set! ((x y ...)) lst)
                 `(let ((,rest (car ,rest)))
                    ,(ds-set!-helper var rest compare?)))
               ;;(ds-set! (x) lst)
               `(set! ,var (car ,rest)))
             (if (pair? var)
               (if (compare? (car var) 'o)
                 (if (atom? (cdr vars))
                   ;;(ds-set! ((o x val) . rest) lst)
                   `(begin 
                      (set! ,(cadr var) (if (null? ,rest) ,(caddr var) (car ,rest))) 
                      (set! ,(cdr vars) (if (null? ,rest) '() (cdr ,rest))))
                   ;;(ds-set! ((o x val) y z ...) lst)
                   `(begin
                      (set! ,(cadr var) 
                        (if (null? ,rest) ,(caddr var) (car ,rest))) 
                      (let ((,rest (if (null? ,rest) '() (cdr ,rest))))
                        ,(ds-set!-helper (cdr vars) rest compare?))))
                 (let ((head (gensym)))
                   (if (atom? (cdr vars))
                     ;;(ds-set! ((a b c ...) . rest) lst)
                     `(let ((,head (car ,rest)))
                        ,(ds-set!-helper var head compare?)
                        (set! ,(cdr vars) (cdr ,rest)))
                     ;;(ds-set! ((a b c ...) x y ...) lst)
                     `(let ((,head (car ,rest)) (,rest (cdr ,rest)))
                        ,(ds-set!-helper var head compare?)
                        ,(ds-set!-helper (cdr vars) rest compare?)))))
             (if (atom? (cdr vars))
               ;;(ds-set! (x . y) lst)
               `(begin 
                  (set! ,var (car ,rest)) 
                  (set! ,(cdr vars) (cdr ,rest)))
               ;;(ds-set! (x y z ...) lst)  
               `(begin 
                  (set! ,var (car ,rest)) 
                  (let ((,rest (cdr ,rest)))
                    ,(ds-set!-helper (cdr vars) rest compare?))))))))))
  

  (define-syntax ds-set!
    (ir-macro-transformer
      (lambda (expr inject compare?)
        (let ((vars (cadr expr))
              (vals (caddr expr))
              (body (cdddr expr))
              (rest 'rest))
          `(let ((rest ,vals))
              ,(ds-set!-helper vars rest compare?))))))
  
  (define-syntax ds-define
  (syntax-rules ()
    ((_ arg lst) 
     (begin 
       (ds-define-false arg)
       (ds-set! arg lst)))))
  
  )



